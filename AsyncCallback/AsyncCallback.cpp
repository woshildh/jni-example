/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <thread>
/* Header for class AsyncCallback */

/*
JNIEnv 的指针不能在不同线程之间传递，必须借助于 AttachCurrentThread() 获取当前线程下的 JNIEnv，在结束时调用DetachCurrentThread
如果当前线程已经被附加到VM上的话，GetEnv和AttachCurrentThread在功能上是等价的。
GetEnv 其实就是检查一下当前线程是否已经绑定了一个JNIEnv, 已经绑定了那么返回指针，没有绑定则返回NULL
*/

#ifndef _Included_AsyncCallback
#define _Included_AsyncCallback
#ifdef __cplusplus
extern "C" {
#endif

JavaVM *g_jvm = NULL;
jclass clsid = NULL;
jmethodID mid = NULL;

void callback() {
    printf("Start running\n");

    JNIEnv *env = NULL;
    // 绑定当前线程
    jint state = g_jvm->AttachCurrentThread((void**)&env, NULL);
    if(state <  0 || env == NULL) {
        printf("DetachCurrentThread failed\n");
        return;
    }
    // 获取类和方法的 id
    clsid = env->FindClass("AsyncCallback");
    mid = env->GetStaticMethodID(clsid, "callback", "(Ljava/lang/String;)V");
    if(!mid) {
        printf("GetStaticMethodID failed.\n");
        return;
    }
    int cishu = 10;
    char buffer[128];
    while(cishu--) {
        sprintf(buffer, "This is %d in native.", cishu);
        // 调用一次 java 方法
        env->CallStaticVoidMethod(clsid, mid, env->NewStringUTF(buffer));
        // 休眠 5s
        std::this_thread::sleep_for(std::chrono::milliseconds(1000 * 5));
    }
    // 分离当前线程 
    g_jvm->DetachCurrentThread();
}

/*
 * Class:     AsyncCallback
 * Method:    InitNativeThread
 * Signature: ()V
 */
JNIEXPORT void JNICALL _Java_AsyncCallback_InitNativeThread(JNIEnv *env, jclass cls) {
    // 初始化全局的指针
    env->GetJavaVM(&g_jvm);
    // 启动线程
    std::thread t = std::thread(callback);
    t.detach();
}


#ifdef __cplusplus
}
#endif
#endif
